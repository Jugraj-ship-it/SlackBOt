import os
import slack_sdk
import requests
import speech_recognition as sr
from pydub import AudioSegment
from datetime import datetime
from flask import Flask, request, jsonify
import threading
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize Flask app for receiving slash commands
app = Flask(__name__)

# Initialize Slack client with your bot token
# NOTE: In production, you should store this in environment variables
SLACK_TOKEN = os.environ.get("SLACK_BOT_TOKEN")  # Don't hardcode tokens
client = slack_sdk.WebClient(token=SLACK_TOKEN)

# Initialize speech recognizer
recognizer = sr.Recognizer()

def download_file(url, file_name):
    """Download a file from a URL with authorization."""
    headers = {"Authorization": f"Bearer {SLACK_TOKEN}"}
    response = requests.get(url, headers=headers)
    if response.status_code != 200:
        logger.error(f"Failed to download file: {response.status_code}")
        return False
        
    with open(file_name, "wb") as f:
        f.write(response.content)
    return True

def transcribe_audio(file_path):
    """Transcribe audio file to text using Google Speech Recognition."""
    try:
        audio = AudioSegment.from_file(file_path)
        wav_path = f"{file_path}.wav"
        audio.export(wav_path, format="wav")
        
        with sr.AudioFile(wav_path) as source:
            audio_data = recognizer.record(source)
            try:
                text = recognizer.recognize_google(audio_data)
                return text
            except sr.UnknownValueError:
                return "Could not understand the audio."
            except sr.RequestError as e:
                logger.error(f"Transcription service error: {str(e)}")
                return "Transcription service unavailable."
    except Exception as e:
        logger.error(f"Error transcribing audio: {str(e)}")
        return f"Error processing audio: {str(e)}"
    finally:
        # Clean up temp files
        if os.path.exists(wav_path):
            os.remove(wav_path)

def format_daily_update(text):
    """Format the transcribed text into a daily update."""
    today = datetime.now().strftime("%B %d, %Y")
    
    # Try to parse the content into sections
    sections = []
    lines = text.split(".")
    
    for line in lines:
        line = line.strip()
        if line:
            sections.append(f"â€¢ {line}.")
    
    formatted_text = "\n".join(sections)
    
    update = f"*Daily Update - {today}*\n\n{formatted_text}\n\n_Generated by VoiceNoteBot_"
    return update

def process_voice_note(file_url, file_type, channel_id, thread_ts=None):
    """Process a voice note and post the update."""
    try:
        file_name = f"temp_audio_{datetime.now().strftime('%Y%m%d%H%M%S')}.{file_type}"
        
        # First post a message indicating processing is happening
        response = client.chat_postMessage(
            channel=channel_id,
            text="Processing your voice note... this may take a moment.",
            thread_ts=thread_ts
        )
        
        if download_file(file_url, file_name):
            transcription = transcribe_audio(file_name)
            update = format_daily_update(transcription)
            
            # Post the formatted update
            client.chat_postMessage(
                channel=channel_id,
                text=update,
                thread_ts=thread_ts
            )
        else:
            client.chat_postMessage(
                channel=channel_id,
                text="Failed to download audio file.",
                thread_ts=thread_ts
            )
    except Exception as e:
        logger.error(f"Error processing voice note: {str(e)}")
        client.chat_postMessage(
            channel=channel_id,
            text=f"Error processing voice note: {str(e)}",
            thread_ts=thread_ts
        )
    finally:
        # Clean up temp files
        if os.path.exists(file_name):
            os.remove(file_name)

@app.route('/slack/events', methods=['POST'])
def slack_events():
    """Handle Slack events."""
    data = request.form
    
    # Verify this is a valid Slack request (in production, add verification)
    
    if data.get('command') == '/dailyupdate':
        channel_id = data.get('channel_id')
        user_id = data.get('user_id')
        thread_ts = data.get('thread_ts')
        
        # Check if a file was uploaded
        if 'files' in data:
            file_data = data['files'][0]
            if file_data['filetype'] in ['mp3', 'm4a', 'wav', 'ogg']:
                # Process the voice note in a separate thread to avoid timeouts
                threading.Thread(
                    target=process_voice_note,
                    args=(file_data['url_private'], file_data['filetype'], channel_id, thread_ts)
                ).start()
                
                return jsonify({
                    "response_type": "ephemeral",
                    "text": "Processing your voice note..."
                })
            else:
                return jsonify({
                    "response_type": "ephemeral",
                    "text": "Please upload a voice note (mp3, m4a, wav, or ogg file)."
                })
        else:
            return jsonify({
                "response_type": "ephemeral",
                "text": "Please upload a voice note with the command."
            })
    
    return jsonify({"status": "ok"})

# Handle slash command file uploads
@app.route('/slack/commands/dailyupdate', methods=['POST'])
def handle_dailyupdate():
    data = request.form
    channel_id = data.get('channel_id')
    user_id = data.get('user_id')
    response_url = data.get('response_url')
    
    # Acknowledge the command immediately
    return jsonify({
        "response_type": "ephemeral",
        "text": "Please upload a voice note to continue."
    })

# Listen for file uploads
@app.route('/slack/events/file_shared', methods=['POST'])
def handle_file_shared():
    data = request.json
    
    if data.get('type') == 'event_callback' and data.get('event', {}).get('type') == 'file_shared':
        event = data['event']
        file_id = event.get('file_id')
        channel_id = event.get('channel_id')
        
        # Get file info
        file_info = client.files_info(file=file_id)
        file_data = file_info.get('file', {})
        
        if file_data.get('filetype') in ['mp3', 'm4a', 'wav', 'ogg']:
            # Process the voice note
            threading.Thread(
                target=process_voice_note,
                args=(file_data['url_private'], file_data['filetype'], channel_id)
            ).start()
    
    return jsonify({"status": "ok"})

if __name__ == "__main__":
    # Run the Flask app
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port)
